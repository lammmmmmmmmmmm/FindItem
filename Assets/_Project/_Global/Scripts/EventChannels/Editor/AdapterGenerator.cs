using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using _Global.EventChannels.PayloadAdapter;
using Item;
using UnityEditor;
using UnityEngine;

namespace _Global.EventChannels.Editor {
    public static class AdapterGenerator {
        [MenuItem("Tools/Generate Adapter From Payload")]
        public static void GenerateAdapter() {
            //TODO: ðŸ‘‡ Replace this with your payload type manually or dynamically later
            var payloadType = typeof(ItemUnloadPayload);
            string payloadTypeName = payloadType.FullName; // includes namespace
            string payloadSimpleName = payloadType.Name;

            var genericPayloadAdapterType = typeof(GenericPayloadAdapter<>);
            var genericPayloadAdapterTypeName = genericPayloadAdapterType.FullName;
            genericPayloadAdapterTypeName =
                genericPayloadAdapterTypeName?.Substring(0, genericPayloadAdapterTypeName.IndexOf('`'));

            string adapterClassName = payloadSimpleName + "Adapter";
            string filePath = $"Assets/Scripts/Generated/{adapterClassName}.cs";

            // Read existing file if it exists
            string existingCode = File.Exists(filePath) ? File.ReadAllText(filePath) : null;

            // Extract existing UnityEvent field names
            var existingFieldNames = existingCode != null
                ? Regex.Matches(existingCode, @"UnityEvent<.+?>\s+on(\w+);")
                    .Cast<Match>()
                    .Select(m => m.Groups[1].Value)
                    .ToHashSet()
                : new HashSet<string>();

            var sb = new StringBuilder();

            // Start file header
            if (existingCode == null) {
                sb.AppendLine("using UnityEngine;");
                sb.AppendLine("using UnityEngine.Events;");
                sb.AppendLine();
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// Auto-generated adapter for {payloadSimpleName}. DO NOT edit this file directly.");
                sb.AppendLine("/// </summary>");
                sb.AppendLine($"public class {adapterClassName} : {genericPayloadAdapterTypeName}<{payloadTypeName}>");
                sb.AppendLine("{");
            } else {
                // Trim the final closing brace
                existingCode = Regex.Replace(existingCode, @"\}\s*$", "");

                // Remove any existing Handle(...) method
                existingCode = Regex.Replace(existingCode,
                    @"\s*protected\s+override\s+void\s+Handle\s*\(.*?\)\s*\{[^}]*\}", "", RegexOptions.Singleline);

                sb.Append(existingCode);
            }

            // Add UnityEvent for full payload if not already present
            if (!existingFieldNames.Contains("Payload")) {
                sb.AppendLine($"    public UnityEvent<{payloadTypeName}> onPayload;");
            }

            // Add UnityEvent fields that don't exist yet
            foreach (var field in payloadType.GetFields(BindingFlags.Public | BindingFlags.Instance)) {
                string eventName = $"on{UpperFirst(field.Name)}";
                if (!existingFieldNames.Contains(UpperFirst(field.Name))) {
                    sb.AppendLine($"    public UnityEvent<{field.FieldType.FullName}> {eventName};");
                }
            }

            sb.AppendLine();

            // Always regenerate the Handle method
            sb.AppendLine($"    protected override void Handle({payloadTypeName} payload)");
            sb.AppendLine("    {");
            sb.AppendLine("        onPayload?.Invoke(payload);");
            foreach (var field in payloadType.GetFields(BindingFlags.Public | BindingFlags.Instance)) {
                string eventName = $"on{UpperFirst(field.Name)}";
                sb.AppendLine($"        {eventName}?.Invoke(payload.{field.Name});");
            }

            sb.AppendLine("    }");

            sb.AppendLine("}");

            // Save it!
            Directory.CreateDirectory("Assets/Scripts/Generated");
            File.WriteAllText(filePath, sb.ToString());
            AssetDatabase.Refresh();

            Debug.Log($"âœ… Adapter updated: {adapterClassName}");
        }

        private static string UpperFirst(string s) {
            return string.IsNullOrEmpty(s) ? s : char.ToUpper(s[0]) + s.Substring(1);
        }
    }
}